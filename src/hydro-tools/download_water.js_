// start as: node ee-runner.js download_water.js <start_index>

var l8 = ee.ImageCollection('LANDSAT/LC8_L1T_TOA')
	.filterDate('2013-06-01', '2015-06-01')

function pad(n, width, z) {
  z = z || '0';
  n = n + '';
  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
}

var crsTransformSetStep = function(step, t) {
  return [step, t[1], t[2], t[3], -step, t[5]];
}

var sumAll = function (a, start, end) {
    var sum = 0;
    for (var i = start; i < end; i++)
        sum += a[i];
    return sum;
};

function otsu(histogram) {
    var total = sumAll(histogram, 0, histogram.length);

    var sum = 0;
    for (var i = 1; i < histogram.length; ++i) {
        sum += i * histogram[i];
    }

    var sumB = 0;
    var wB = 0;
    var wF = 0;
    var mB;
    var mF;
    var max = 0.0;
    var between = 0.0;
    var threshold1 = 0.0;
    var threshold2 = 0.0;

    for (var j = 0; j < histogram.length; ++j) {
        wB += histogram[j];
        if (wB == 0)
            continue;

        wF = total - wB;
        if (wF == 0)
            break;
        sumB += j * histogram[j];
        mB = sumB / wB;
        mF = (sum - sumB) / wF;
        between = wB * wF * Math.pow(mB - mF, 2);
        if ( between >= max ) {
            threshold1 = j;
            if ( between > max ) {
                threshold2 = j;
            }
            max = between;
        }
    }
    return ( threshold1 + threshold2 ) / 2.0;
}

var max_I = 0.6

var percentile = null // specified using args

var water_index_name = null; // specified using args

var clipBounds = true;

var useRealImage = false

var classifyHand = false;

var useMap = false; // otherwise use feature
//var useMap = true; // otherwise use feature

var bufferSize = 30;

var dem = ee.Image('USGS/SRTMGL1_003');
var info = dem.getInfo()
var crs = info.bands[0].crs
var crs_transform = info.bands[0].crs_transform

var grid = ee.FeatureCollection('ft:1EI0slUr477ZKM3IWv-OOh0invsIXbUoaW9tixrzT')

var downloadTileData = function(feature) {
  var featureId = feature.get('id').getInfo();

  print('Computing water mask and threshold or feature: ' + featureId + ' ...');

  // or specified geometry
  var bounds = ee.Geometry(feature.geometry());

  var images = l8.filterBounds(bounds).select(['B6','B5', 'B3'])
	

  var image = images.reduce(ee.Reducer.intervalMean(percentile, percentile + 1))
  image = image.select(['B6_mean','B5_mean', 'B3_mean'], ['B6','B5', 'B3'])

  var mndwi = image.normalizedDifference(['B6', 'B3'])
  var ndwi = image.normalizedDifference(['B5', 'B3'])

  image = image.clip(bounds)
  mndwi = mndwi.clip(bounds)

  var bounds2 = ee.Geometry(bounds).buffer(-bufferSize);


  var commandLine = true;

  function getSimpleEdge(i) {
    var canny = ee.Algorithms.CannyEdgeDetector(i, 0.99, 0);
    canny = canny.mask(canny).clip(bounds2)
    return canny;

  /* does not work for small rivers
    var delta = 30;
    var edge = i.subtract(i.focal_min(delta, 'square', 'meters'));
    return edge.mask(edge)
  */
  }













// THIS FUNCTION IS SHARED BETWEEN PLAYGROUND AND COMMAND LINE


var detectWater = function(water_index, water_index_name, visible, show_charts) {
  // 45%
  var waterEdgeDetectionThreshold = 0.9
  var waterEdgeRelaxationValue = 0.1
  var waterEdgeMaxPixelRatio = 3.0

  // 15%
  /*
  var waterEdgeDetectionThreshold = 0.99
  var waterEdgeRelaxationValue = 0.02
  var waterEdgeMaxPixelRatio = 1.0
  */

  var waterEdgeDetectionSigma = 0.7
  var waterEdgeMinPixelCountBeforRelaxation = 100
  var waterEdgeRelaxationMinValue = water_index_name == 'mndwi' ? -0.1 : 0.0
  var minWaterEdgePixels = 4

  // prevent relaxation
  //waterEdgeRelaxationMinValue = 1.0


  var methodScale = 15

  if(!commandLine) {
    Map.addLayer(water_index.sldStyle(water_index_style), {}, water_index_name, false)
    Map.addLayer(water_index, water_index_vis, water_index_name + ' (B/W)', false)
    
    addHand()
  }
  
  var water0 = water_index.lt(0)
  var edge0 = getSimpleEdge(water0)
  
  Map.addLayer(image.mask(water0), {min:[0.03,0.03,0.03], max:[0.4,0.4,0.3], gamma:1.5}, 'water (0)', false)
  Map.addLayer(edge0/*.focal_max(1)*/, {palette:'ff0000'}, 'water, ' + water_index_name + '=0 (boundary)', false)

  var canny1 = ee.Algorithms.CannyEdgeDetector(water_index.clip(bounds), waterEdgeDetectionThreshold, waterEdgeDetectionSigma);
  
  var canny = canny1.mask(canny1).clip(bounds2)
    //.reproject(crs, crsTransformSetStep(crs_transform[0] / 2, crs_transform))
    //.reproject(crs, crs_transform)
  
  // have to compute number of canny pixels, otherwise it gives 1, but not in Playground!
  var cannyCount = canny.reduceRegion(ee.Reducer.count(), bounds, methodScale).getInfo()['nd'];
  print('number of Canny pixels: ' + cannyCount)

  if(cannyCount >= minWaterEdgePixels) {
    Map.addLayer(canny, {min: 0, max: 1, palette: 'FF0000'}, 'canny ' + water_index_name, false);
    
    //var cannySmallRiver = canny.focal_max(40, 'square', 'meters')
    //Map.addLayer(cannyRiver.mask(cannySmallRiver), {}, 'canny max', true);
  
    var cannyBuffer = canny.focal_max(methodScale, 'square', 'meters');
  
    var water_index_canny = water_index.mask(cannyBuffer)
    .clip(bounds2);
    
    if(!commandLine) {
      if(show_charts) {
        print(Chart.image.histogram(water_index, bounds2, methodScale, 255).setOptions({title: water_index_name, vAxis: { gridlines: { count: 0 } }, hAxis: { gridlines: { count: 0 }, viewWindow:{max:-1, min:1} }}));
        print(Chart.image.histogram(water_index_canny, bounds2, methodScale, 255).setOptions({title: water_index_name + ' around canny', vAxis: { gridlines: { count: 0 } }, hAxis: { gridlines: { count: 0 },viewWindow:{max:-1, min:1} }}));
      }
    
      Map.addLayer(water_index_canny, water_index_vis, water_index_name + ' around canny', false);
    }
  }
  
  // Otsu using all values
  var computeThreshold = function(water_index, name, bounds) {
    if(cannyCount < minWaterEdgePixels) {
      hist_info = { "error" : "Too few canny edges detected.", "threshold" : -1 }
      return [-1, hist_info];
    }
    
    var hist_info = water_index.reduceRegion(ee.Reducer.histogram(255), bounds, methodScale).getInfo()['nd'];

    var error = null;
  
    if(hist_info === null) { 
      error = 'No water edges detected!'
      threshold = -1;
    } else {
      var hist = hist_info['histogram'] 
      var threshold_index = otsu(hist)
      var threshold = hist_info['bucketMeans'][Math.round(threshold_index)]; 
  
      print(water_index_name + ', ' + name + ': ' + threshold)
    }
  

    if(commandLine) {
      if(threshold != -1) {
         hist_info.threshold = threshold;
      } else {
         hist_info = { "threshold" : -1 }
      }
  
      if(error != null) {
        hist_info.error = error;
      }
    }

    return [threshold, hist_info];
  }

  var th = computeThreshold(water_index_canny, 'canny', bounds2);
  var hist_info = th[1]
  var water_index_threshold = th[0];

  water = ee.Image(0).clip(bounds)
  var waterEdge = ee.Image(0).mask(ee.Image(0)).clip(bounds)
  var waterEdgeCount = 0;
  
  // decrease threshold  if we have too many edges in the thresholded image to avoid misclassification
  if(water_index_threshold != -1) {
    do {
      var water = water_index.lt(water_index_threshold)

      waterEdge = getSimpleEdge(water)
      waterEdgeCount = waterEdge.reduceRegion(ee.Reducer.count(), bounds, methodScale).getInfo()['nd'];
      print('number of water Canny pixels: ' + waterEdgeCount)

      if(clipBounds) {
        water = water.clip(bounds)
      }

      if(waterEdgeCount > cannyCount * waterEdgeMaxPixelRatio
        && water_index_threshold > waterEdgeRelaxationMinValue && waterEdgeCount > waterEdgeMinPixelCountBeforRelaxation ) {
          print('Decreasing threshold by ' + waterEdgeRelaxationValue + ', number of edges around water is > ' + waterEdgeMaxPixelRatio + 'x number of detected edges!')
          water_index_threshold = water_index_threshold - waterEdgeRelaxationValue
      } else {
        print(water_index_name + ': ' + water_index_threshold)
        break;
      }
    } while(true)
  }

  if(commandLine) {
    hist_info.threshold_original = hist_info.threshold
    hist_info.threshold = water_index_threshold;

    save(JSON.stringify(hist_info), pad(featureId, 5) + '_water_' + percentile + '_histogram.json');  
  }
  
  if(!commandLine) {
    Map.addLayer(rgb.mask(water), {min:[0.03,0.03,0.03], max:[0.4,0.4,0.5], gamma:1.5}, 'water ' + water_index_name, visible)
  }
  
  if(classifyHand) {
    // classifyManual(rgb.mask(water))
    classifyUsingHand(rgb.mask(water))
  }

  Map.addLayer(waterEdge/*.focal_max(1)*/, {palette:'aaaaff'}, 'water (boundary) ' + water_index_name, visible)
  Map.addLayer(waterEdge/*.focal_max(1)*/, {palette:'ff0000'}, 'water (boundary), red ' + water_index_name, false)
  Map.addLayer(waterEdge, {palette:'0000ff'}, 'water (boundary), blue ' + water_index_name, false)

  // add water masked by HAND
  /*
  var water_h = water.mask(hand.gt(30))
  Map.addLayer(rgb.mask(water_h), {min:[0.03,0.03,0.03], max:[0.4,0.4,0.3], gamma:1.5}, 'water (HAND > 30m)' + water_index_name, false)
  var canny_h = ee.Algorithms.CannyEdgeDetector(water_h, 0.99, 0);
  canny_h = canny_h.mask(canny_h).clip(bounds2)
  Map.addLayer(canny_h.focal_max(1), {palette:'ff0000'}, 'water (HAND > 30m, boundary), red ' + water_index_name, false)

  var water_h = water.mask(hand.gt(50))
  Map.addLayer(rgb.mask(water_h), {min:[0.03,0.03,0.03], max:[0.4,0.4,0.3], gamma:1.5}, 'water (HAND > 50m)' + water_index_name, false)
  var canny_h = ee.Algorithms.CannyEdgeDetector(water_h, 0.99, 0);
  canny_h = canny_h.mask(canny_h).clip(bounds2)
  Map.addLayer(canny_h.focal_max(1), {palette:'ff0000'}, 'water (HAND > 50m, boundary), red ' + water_index_name, false)
  */

    var name = pad(featureId, 5) + '_water_' + percentile;
    var url = image.mask(water).visualize({min:[0.03,0.03,0.03], max:[0.4,0.4,0.3], gamma:2.0}).getDownloadURL({
      name: name,
      crs: crs,
      format: 'png',
      //crs_transform: JSON.stringify(crsTransformSetStep(crs_transform[0] / 2, crs_transform)),
      crs_transform: JSON.stringify(crs_transform),
      region: JSON.stringify(bounds.coordinates().getInfo()[0]),
    });

    if(commandLine) {
       download(url, name + '.zip')
    } else {
       // print(url);
    }

    var name = pad(featureId, 5) + '_' + water_index_name + '_' + percentile;
    var url = water_index.getDownloadURL({
      name: name,
      crs: crs,
      //crs_transform: JSON.stringify(crsTransformSetStep(crs_transform[0] / 2, crs_transform)),
      crs_transform: JSON.stringify(crs_transform),
      region: JSON.stringify(bounds.coordinates().getInfo()[0]),
    });

    if(commandLine) {
       download(url, name + '.zip')
    } else {
       // print(url);
    }

    if(water_index_name == 'mndwi') { // download just once, TODO: move to arguments
      var name = pad(featureId, 5) + '_swir1_nir_green_' + percentile
      var url = image.visualize({min:0.05, max:[max_I, max_I, max_I + 0.1], gamma:1.5}).getDownloadURL({
        name: name,
        format: 'png',
        crs: crs,
        //crs_transform: JSON.stringify(crsTransformSetStep(crs_transform[0] / 2, crs_transform)),
        crs_transform: JSON.stringify(crs_transform),
        region: JSON.stringify(bounds.coordinates().getInfo()[0]),
      });
  
      if(commandLine) {
         download(url, name + '.zip')
      } else {
         // print(url);
      }
    }
}













  /*
  var detectWater = function(water_index, water_index_name, visible, show_charts) {
    var canny = ee.Algorithms.CannyEdgeDetector(water_index.clip(bounds), 0.99, 0.7);
    canny = canny.mask(canny).clip(bounds2)
      .reproject(crs, crs_transform)

    // have to compute number of canny pixels, otherwise it gives 1, but not in Playground!
    var cannyCount = canny.reduceRegion(ee.Reducer.count(), bounds, 30).getInfo()['nd'];

    var cannyBuffer = canny.focal_max(30, 'square', 'meters');

    var water_index_canny = water_index.mask(cannyBuffer)
      .clip(bounds2);

    // Otsu using all values
    var computeThreshold = function(water_index, name, bounds) {
      var hist_info = water_index.reduceRegion(ee.Reducer.histogram(255), bounds, 30).getInfo()['nd'];

      var error = null;
    
      if(hist_info === null) { 
        error = 'No water edges detected!'
        threshold = -1;
      } else if(cannyCount < 4) {
        error = 'Too few water edges!'
        threshold = -1
      } else {
        var hist = hist_info['histogram'] 
        var threshold_index = otsu(hist)
        var threshold = hist_info['bucketMeans'][Math.round(threshold_index)]; 
    
        print(water_index_name + ', ' + name + ': ' + threshold)
      }
    
      if(threshold != -1) {
         hist_info.threshold = threshold;
      } else {
         hist_info = { "threshold" : -1 }
      }

      if(error != null) {
          hist_info.error = error;
      }

      return [threshold, hist_info];
    }

    var th = computeThreshold(water_index_canny, 'canny', bounds2);
    var hist_info = th[1]
    var water_index_threshold = th[0];

    var water = ee.Image(0).clip(bounds)

    // decrease threshold  if we have too many edges in the thresholded image to avoid misclassification
    if(water_index_threshold != -1) {
      do {
        water = water_index.lt(water_index_threshold)

        var canny = ee.Algorithms.CannyEdgeDetector(water, 0.99, 0);
        canny = canny.mask(canny).clip(bounds2)
     
        var cannyWaterCount = canny.reduceRegion(ee.Reducer.count(), bounds, 30).getInfo()['nd'];
        print('number of water Canny pixels: ' + cannyWaterCount)

        if(clipBounds) {
          water = water.clip(bounds)
        }

        if(cannyWaterCount > cannyCount * 3) {
            print('Decreasing threshold by 0.02, number of edges around water is > 3x number of detected edges!')
    
            water_index_threshold = water_index_threshold - 0.02
        } else {
            hist_info.threshold_original = hist_info.threshold
            hist_info.threshold = water_index_threshold;
            print(water_index_name + ': ' + water_index_threshold)
            break;
        }
      } while(true)
    }

    save(JSON.stringify(hist_info), pad(featureId, 5) + '_water_' + percentile + '_histogram.json');

    var name = pad(featureId, 5) + '_water_' + percentile;
    var url = image.mask(water).visualize({min:[0.03,0.03,0.03], max:[0.4,0.4,0.3], gamma:2.0}).getDownloadURL({
      name: name,
      crs: crs,
      format: 'png',
      //crs_transform: JSON.stringify(crsTransformSetStep(crs_transform[0] / 2, crs_transform)),
      crs_transform: JSON.stringify(crs_transform),
      region: JSON.stringify(bounds.coordinates().getInfo()[0]),
    });
    download(url, name + '.zip')

    var name = pad(featureId, 5) + '_ndwi_' + percentile;
    var url = water_index.getDownloadURL({
      name: name,
      crs: crs,
      //crs_transform: JSON.stringify(crsTransformSetStep(crs_transform[0] / 2, crs_transform)),
      crs_transform: JSON.stringify(crs_transform),
      region: JSON.stringify(bounds.coordinates().getInfo()[0]),
    });
    download(url, name + '.zip')

    if(spectral_index == 'mndwi') { // download just once, TODO: move to arguments
      var name = pad(featureId, 5) + '_swir1_nir_green_' + percentile
      var url = image.visualize({min:0.05, max:[max_I, max_I, max_I + 0.1], gamma:1.5}).getDownloadURL({
        name: name,
        format: 'png',
        crs: crs,
        //crs_transform: JSON.stringify(crsTransformSetStep(crs_transform[0] / 2, crs_transform)),
        crs_transform: JSON.stringify(crs_transform),
        region: JSON.stringify(bounds.coordinates().getInfo()[0]),
      });
      download(url, name + '.zip')
    }
  }
  */

  // water_index, water_index_name, visible, show_charts
  if (water_index_name == 'ndwi') {
    detectWater(ndwi, 'ndwi', true, true)
  } else if (water_index_name == 'mndwi') {
    detectWater(mndwi, 'mndwi', false, true)
  }
}


var downloadMissing = (args[1] === "missing");

var percentile = parseInt(args[2])
 
var water_index_name = args[3]

var path = require('path');

if(downloadMissing) {
    var config = require(path.join(process.cwd(), "missing.json"))
    var missing = config.missing;

    for(var i = 0; i < missing.length; i++) {
      var id = missing[i];
      print('Processing: ' + id)
      var feature = ee.Feature(grid.filter(ee.Filter.eq('id', id)).first());
      downloadTileData(feature)
    }
} else {
    var start_index = parseInt(args[4]);
    var max_index = parseInt(args[5]);
 
    var count = grid.aggregate_count('id').getInfo()

    if(max_index > 0) {
       count = max_index + 1;
    }

    var features = grid.sort('id').toList(count, 0);

    for(var i = start_index; i < count; i++) {
      print('Processing: ' + i)
      var feature = ee.Feature(features.get(i));
      downloadTileData(feature)

      var idx_path = path.join(process.cwd(), 'download_water.js.last');
      save(i + 1, idx_path)
    }
}
